-- Service-as-a-Product schema migration
-- Creates public.services (uuid PK) and refactors public.orders for service ecommerce mode

-- 1) services table
create table if not exists public.services (
  id uuid primary key default gen_random_uuid(),
  creator_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  price numeric(10, 2) not null,
  cover_url text,
  description text,
  tags text[],
  rating numeric(3, 2) default 0
);

alter table public.services enable row level security;

-- Policies: anyone can read, only creator can modify
create policy "Services are viewable by everyone." on public.services
  for select using (true);

create policy "Creators can insert their own services." on public.services
  for insert with check (auth.uid() = creator_id);

create policy "Creators can update their own services." on public.services
  for update using (auth.uid() = creator_id);

create policy "Creators can delete their own services." on public.services
  for delete using (auth.uid() = creator_id);


-- 2) orders table refactor
-- Ensure required extension for gen_random_uuid()
-- Supabase typically enables pgcrypto by default. If not, uncomment:
-- create extension if not exists pgcrypto;

create table if not exists public.orders (
  id bigint generated by default as identity primary key,
  buyer_id uuid not null references auth.users(id) on delete cascade,
  service_owner_id uuid references auth.users(id) on delete set null,
  service_id uuid references public.services(id) on delete set null,
  amount numeric(10, 2) not null,
  status text not null default 'pending',
  service_snapshot jsonb,
  delivery_url text,
  created_at timestamptz not null default timezone('utc'::text, now())
);

-- If an existing orders table is present from the old schema, drop incompatible columns if they exist.
-- Note: dropping columns may require dropping dependent constraints/policies first.
alter table public.orders
  drop column if exists job_id,
  drop column if exists client_id,
  drop column if exists final_amount,
  drop column if exists worker_id,
  drop column if exists completed_at;

-- Add/rename columns to match ecommerce mode
alter table public.orders
  add column if not exists buyer_id uuid references auth.users(id) on delete cascade,
  add column if not exists service_owner_id uuid references auth.users(id) on delete set null,
  add column if not exists service_id uuid references public.services(id) on delete set null,
  add column if not exists amount numeric(10, 2),
  add column if not exists status text,
  add column if not exists service_snapshot jsonb,
  add column if not exists delivery_url text,
  add column if not exists created_at timestamptz;

-- Set defaults / not null where safe
alter table public.orders
  alter column status set default 'pending';

update public.orders set created_at = timezone('utc'::text, now()) where created_at is null;

alter table public.orders
  alter column created_at set default timezone('utc'::text, now());

-- If you are migrating from old data, you must backfill buyer_id/amount before enforcing NOT NULL.
-- For a clean slate MVP, you can truncate orders then enforce NOT NULL constraints.

alter table public.orders enable row level security;

-- Drop old policies if they exist (names from previous iterations)
drop policy if exists "Users can only see their own orders (as client or part of the team)." on public.orders;
drop policy if exists "Clients can create orders for their jobs." on public.orders;
drop policy if exists "Users can view their own orders." on public.orders;
drop policy if exists "Users can create their own orders." on public.orders;

-- New RLS policies for ecommerce orders
create policy "Buyers can view their own orders." on public.orders
  for select using (auth.uid() = buyer_id);

create policy "Creators can view incoming orders." on public.orders
  for select using (auth.uid() = service_owner_id);

create policy "Buyers can create their own orders." on public.orders
  for insert with check (auth.uid() = buyer_id);

create policy "Buyers can update their own orders (optional)." on public.orders
  for update using (auth.uid() = buyer_id);

create policy "Creators can update incoming orders." on public.orders
  for update using (auth.uid() = service_owner_id);
